<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.comma_groupware.mapper.EmployeeMapper">
	
	<!-- SpringSecurity 로그인에 사용  -->
	<select id="selectByUserName" parameterType="string"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.password,
      e.emp_email     AS empEmail,
      e.emp_name      AS empName,
      e.emp_status    AS empStatus,
      e.emp_phone     AS empPhone,
      e.emp_exp       AS empExp,
      e.`role`        AS role,
      e.created_at    AS createdAt,
      e.updated_at    AS updatedAt
    FROM employee e
    WHERE e.username = #{username}
    LIMIT 1
  </select>

	  <!-- 사원 ID로 조회 -->
  <select id="selectById" parameterType="int"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.password,
      e.emp_email     AS empEmail,
      e.emp_name      AS empName,
      e.emp_status    AS empStatus,
      e.emp_phone     AS empPhone,
      e.emp_exp       AS empExp,
      e.`role`        AS role,
      e.created_at    AS createdAt,
      e.updated_at    AS updatedAt
    FROM employee e
    WHERE e.emp_id = #{empId}
  </select>

  <!-- 부서별 조회: department_history → team → department -->
  <select id="selectByDeptId" parameterType="int"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.emp_name      AS empName,
      t.dept_id       AS deptId,
      e.`role`        AS role,
      e.emp_status    AS empStatus
    FROM employee e
    JOIN department_history dh
      ON dh.emp_id = e.emp_id
     AND dh.end_date IS NULL
    JOIN team t
      ON t.team_id = dh.team_id
    WHERE t.dept_id = #{deptId}
  </select>

  <!-- 팀별 조회: department_history 사용 -->
  <select id="selectByTeamId" parameterType="int"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.emp_name      AS empName,
      dh.team_id      AS teamId,
      e.`role`        AS role,
      e.emp_status    AS empStatus
    FROM employee e
    JOIN department_history dh
      ON dh.emp_id = e.emp_id
     AND dh.end_date IS NULL
    WHERE dh.team_id = #{teamId}
  </select>

  <!-- 직급별 조회: rank_history 사용 -->
  <select id="selectByRankId" parameterType="int"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.emp_name      AS empName,
      rh.rank_id      AS rankId,
      e.`role`        AS role,
      e.emp_status    AS empStatus
    FROM employee e
    JOIN rank_history rh
      ON rh.emp_id = e.emp_id
     AND rh.end_date IS NULL
    WHERE rh.rank_id = #{rankId}
  </select>

  <!-- 키워드 검색 -->
  <select id="searchEmployees" parameterType="string"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.emp_name      AS empName,
      e.emp_email     AS empEmail,
      e.emp_status    AS empStatus,
      e.`role`        AS role
    FROM employee e
    WHERE e.username LIKE CONCAT('%', #{keyword}, '%')
       OR e.emp_name LIKE CONCAT('%', #{keyword}, '%')
  </select>

  <!-- 상태별 조회 -->
  <select id="selectByStatus" parameterType="string"
          resultType="com.example.comma_groupware.dto.Employee">
    SELECT
      e.emp_id        AS empId,
      e.username,
      e.emp_name      AS empName,
      e.emp_status    AS empStatus,
      e.`role`        AS role
    FROM employee e
    WHERE e.emp_status = #{status}
  </select>

  <!-- 현재 부서 조회: employee → department_history → team → department -->
  <select id="getCurrentDepartment" parameterType="int"
          resultType="com.example.comma_groupware.dto.Department">
    SELECT
      d.dept_id       AS deptId,
      d.dept_name     AS deptName
    FROM employee e
    JOIN department_history dh
      ON dh.emp_id = e.emp_id
     AND dh.end_date IS NULL
    JOIN team t
      ON t.team_id = dh.team_id
    JOIN department d
      ON d.dept_id = t.dept_id
    WHERE e.emp_id = #{empId}
  </select>

  <!-- 현재 직급 조회 -->
  <select id="getCurrentRank" parameterType="int"
          resultType="com.example.comma_groupware.dto.RankHistory">
    SELECT
      rh.rank_history_id,
      rh.emp_id,
      rh.rank_id,
      rh.start_date,
      rh.end_date
    FROM rank_history rh
    WHERE rh.emp_id = #{empId}
      AND rh.end_date IS NULL
    ORDER BY rh.start_date DESC
    LIMIT 1
  </select>

	<!-- 비밀번호 업데이트에 사용 -->
	<update id="updatePw" parameterType="string">
	UPDATE
		employee SET 
	password = #{password}
	WHERE username = #{username}
	</update>
	
	
	<!-- 이메일이 존재하는지 확인 -->
	<select id="existsByEmail" parameterType="string">
	SELECT
		COUNT(*)
	FROM employee
	WHERE emp_email = #{email}
	
	</select>
	
	<!-- 개인정보 업데이트에 사용 -->
	<update id="updateInfo" parameterType="string">
	UPDATE
		employee SET
		emp_email = #{email},
		emp_phone = #{phone}
	WHERE username = #{username}
	
	</update>

	<!-- 조직도 리스트 -->
	<select id="organizationList" parameterType="com.example.comma_groupware.dto.Page" resultType="map">
		SELECT 
			e.emp_id AS empId,
			e.emp_name AS empName,
			e.emp_email AS empEmail,
			r.rank_name AS rankName,
			d.dept_name AS deptName,
			t.team_name AS teamName
		FROM
		(
			SELECT * FROM employee
			WHERE emp_status = '재직'
			<if test="searchList.name != ''">
			AND emp_name LIKE CONCAT('%', #{searchList.name}, '%')
			</if>
		) e
		LEFT OUTER JOIN (SELECT * from department_history WHERE end_date IS NULL) dh ON e.emp_id = dh.emp_id
		
		<!-- 
			만약 부서/팀 검색 옵션이 있으면 INNER JOIN 으로 해당하는 부서/팀만 나오게 하고
			검색 옵션이 없으면 OUTER JOIN으로 부서/팀 배정 받지않은 사원도 조회되게 함
		 -->
		<if test="searchList.team != ''">
		INNER JOIN (
			SELECT * FROM team
			WHERE team_name LIKE CONCAT('%', #{searchList.team}, '%')
		) t ON t.team_id = dh.team_id
		</if>
		
		<if test="searchList.team == ''">
		LEFT OUTER JOIN team t ON t.team_id = dh.team_id
		</if>
		
		<if test="searchList.dept != ''">
		INNER JOIN (
			SELECT * FROM department
			WHERE dept_name LIKE CONCAT('%', #{searchList.dept}, '%')
		) d ON d.dept_id = t.dept_id
		</if>
		
		<if test="searchList.dept == ''">
		LEFT OUTER JOIN department d ON d.dept_id = t.dept_id
		</if>
		
		LEFT OUTER JOIN (SELECT * from rank_history WHERE end_date IS NULL) rh ON e.emp_id = rh.emp_id
		LEFT OUTER JOIN `rank` r ON r.rank_id = rh.rank_id
		
		<if test="searchList.order == 'empName'">
			ORDER BY empName
		</if>
		<if test="searchList.order == 'empEmail'">
			ORDER BY empEmail
		</if>
		<if test="searchList.order == 'rankName'">
			ORDER BY rankName
		</if>
		<if test="searchList.order == 'deptName'">
			ORDER BY deptName
		</if>
		<if test="searchList.order == 'teamName'">
			ORDER BY teamName
		</if>
		
		<if test="searchList.sort == 'desc'">
			DESC
		</if>
		LIMIT #{beginRow}, #{rowPerPage};
	</select>

	<!-- 조직도 리스트 전체 데이터 카운트 -->
	<select id="organizationListCount" parameterType="map" resultType="Integer">
		SELECT 
			count(*) AS count
		FROM
		(
			SELECT * FROM employee
			WHERE emp_status = '재직'
			<if test="name != ''">
				AND emp_name LIKE CONCAT('%', #{name}, '%')
			</if>
		) e
		LEFT OUTER JOIN (SELECT * from department_history WHERE end_date IS NULL) dh ON e.emp_id = dh.emp_id
		<!-- 
			만약 부서/팀 검색 옵션이 있으면 INNER JOIN 으로 해당하는 부서/팀만 나오게 하고
			검색 옵션이 없으면 OUTER JOIN으로 부서/팀 배정 받지않은 사원도 조회되게 함
		 -->
		<if test="team != ''">
		INNER JOIN (
			SELECT * FROM team
			WHERE team_name LIKE CONCAT('%', #{team}, '%')
		) t ON t.team_id = dh.team_id
		</if>
		
		<if test="team == ''">
		LEFT OUTER JOIN team t ON t.team_id = dh.team_id
		</if>
		
		<if test="dept != ''">
		INNER JOIN (
			SELECT * FROM department
			WHERE dept_name LIKE CONCAT('%', #{dept}, '%')
		) d ON d.dept_id = t.dept_id
		</if>
		
		<if test="dept == ''">
		LEFT OUTER JOIN department d ON d.dept_id = t.dept_id
		</if>
		LEFT OUTER JOIN (SELECT * from rank_history WHERE end_date IS NULL) rh ON e.emp_id = rh.emp_id
		LEFT OUTER JOIN `rank` r ON r.rank_id = rh.rank_id
	</select>
	
	<select id="employeeCard" parameterType="int" resultType="map">
		SELECT 
			e.emp_id AS empId,
			e.emp_name AS empName,
			d.dept_name AS deptName,
			t.team_name AS teamName,
			r.rank_name AS rankName,
			e.emp_email AS empEmail
		FROM (SELECT * FROM employee WHERE emp_id = #{empId}) e
		LEFT OUTER JOIN (SELECT * from department_history WHERE end_date IS NULL) dh ON e.emp_id = dh.emp_id
		LEFT OUTER JOIN team t ON t.team_id = dh.team_id
		LEFT OUTER JOIN department d ON d.dept_id = t.dept_id
		LEFT OUTER JOIN (SELECT * from rank_history WHERE end_date IS NULL) rh ON e.emp_id = rh.emp_id
		LEFT OUTER JOIN `rank` r ON r.rank_id = rh.rank_id
	</select>
	
	<select id="empListByTeam" parameterType="String">
		SELECT
			e.emp_id AS empId,
			r.rank_name AS rankName,
			e.emp_name AS empName,
			CONCAT(e.emp_exp,'년차') AS empExp
		FROM employee e
		INNER JOIN
		(SELECT * FROM department_history WHERE end_date IS NULL AND team_id = (
			SELECT team_id FROM team WHERE team_name = #{team}
		)) dh ON e.emp_id = dh.emp_id
		INNER JOIN (SELECT * FROM rank_history WHERE end_date IS NULL) rh ON e.emp_id = rh.emp_id
		INNER JOIN `rank` r ON rh.rank_id = r.rank_id
		ORDER BY empExp DESC
	</select>
	
</mapper>
