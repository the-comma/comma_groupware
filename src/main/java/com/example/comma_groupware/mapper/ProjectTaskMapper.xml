<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper
	namespace="com.example.comma_groupware.mapper.ProjectTaskMapper">
	
	<!-- 댓글 조회 -->
	<select id="selectTaskCommentByTaskId" parameterType="int" resultType="map">
			WITH RECURSIVE comment_tree AS (
		    -- 1. 최상위 댓글 (부모 없는 댓글)
		    SELECT 
		        tc.task_comment_id,
		        tc.writer_id,
		        e.emp_name,
		        tc.task_comment_content,
		        tc.created_at,
		        tc.task_comment_parent,
		        0 AS depth,
		        CAST(tc.task_comment_id AS CHAR(200)) AS path
		    FROM task_comment tc
		    INNER JOIN employee e ON e.emp_id = tc.writer_id
		    WHERE tc.task_id = #{taskId} 
		      AND tc.task_comment_parent IS NULL
		
		    UNION ALL
		
		    -- 2. 답글 (부모를 가진 댓글)
		    SELECT 
		        c.task_comment_id,
		        c.writer_id,
		        e.emp_name,
		        c.task_comment_content,
		        c.created_at,
		        c.task_comment_parent,
		        ct.depth + 1,
		        CONCAT(ct.path, '>', c.task_comment_id)
		    FROM task_comment c
		    INNER JOIN employee e ON e.emp_id = c.writer_id
		    INNER JOIN comment_tree ct ON c.task_comment_parent = ct.task_comment_id
		)
		SELECT 
		    task_comment_id AS taskCommentId,
		    writer_id AS writerId,
		    emp_name AS empName,
		    task_comment_content AS taskCommentContent,
		    created_at AS createdAt,
		    task_comment_parent AS parentId,
		    depth
		FROM comment_tree
		ORDER BY path, createdAt;
	</select>
	
	<!-- 댓글 작성 -->
	<insert id="addTaskComment" parameterType="com.example.comma_groupware.dto.TaskComment">
		INSERT INTO task_comment(
			writer_id, task_id, task_comment_parent, task_comment_content
		) VALUES(
			#{writerId}, #{taskId}, #{taskCommentParent}, #{taskCommentContent}
		)
	</insert>
	
	<!-- 댓글 수정 -->
	<update id="modifyComment" parameterType="com.example.comma_groupware.dto.TaskComment">
		UPDATE task_comment SET task_comment_content = #{taskCommentContent}
		WHERE task_comment_id = #{taskCommentId} 
	</update>
	
	<!-- 댓글 삭제 -->
	<delete id="deleteComment" parameterType="int">
		DELETE FROM task_comment
		WHERE task_comment_id = #{taskCommentId}
	</delete>
	
	<!-- 작업 추가 -->
	<insert id="addProjectTask" parameterType="com.example.comma_groupware.dto.ProjectTask"
		useGeneratedKeys="true" keyProperty="taskId">
		
		INSERT INTO project_task(
			task_parent, project_id, writer_id, task_title, task_desc, task_status, file_count, start_date, due_date
		) VALUES(
			#{taskParent}, #{projectId}, #{writerId}, #{taskTitle}, #{taskDesc}, #{taskStatus}, #{fileCount}, #{startDate}, #{dueDate}
		)
	</insert>
	
	<!-- 프로젝트 아이디로 작업 리스트 조회 -->
	<select id="selectTaskListByProjectId" parameterType="map">
		WITH RECURSIVE task_tree AS (
		    -- 1. 최상위 업무부터 시작
		    SELECT 
		        pt.task_id AS taskId,
		        pt.task_title AS taskTitle,
		        pt.writer_id AS writerId,
		        pt.task_desc AS taskDesc,
		        pt.task_status AS taskStatus,
		        pt.start_date AS startDate,
		        pt.due_date AS dueDate,
		        pt.task_parent AS taskParent,
		        0 AS level,
		        CAST(pt.task_id AS CHAR(200)) AS sort_path
		    FROM project_task pt
		    WHERE pt.project_id = #{projectId}
		      AND (pt.task_parent IS NULL OR pt.task_parent = 0)
		
		    UNION ALL
		
		    -- 2. 하위 업무를 재귀적으로 가져오기
		    SELECT 
		        pt.task_id,
		        pt.task_title,
		        pt.writer_id,
		        pt.task_desc,
		        pt.task_status,
		        pt.start_date,
		        pt.due_date,
		        pt.task_parent,
		        tt.level + 1 AS level,
		        CONCAT(tt.sort_path, '-', pt.task_id) AS sort_path
		    FROM project_task pt
		    INNER JOIN task_tree tt ON pt.task_parent = tt.taskId
		)
		SELECT 
		    tt.*,
		    w.emp_name AS writerName,
		    m.memberCount,
		    m.first_emp_id AS firstEmpId,
		    e.emp_name AS memberName,
		    (SELECT COUNT(*) FROM project_task WHERE task_parent = tt.taskId) AS childCount
		FROM task_tree tt
		LEFT JOIN (
		    SELECT 
		        tm.task_id, 
		        COUNT(*) AS memberCount,
		        (SELECT tm2.emp_id
		         FROM task_member tm2
		         WHERE tm2.task_id = tm.task_id
		         ORDER BY tm2.assigned_at ASC
		         LIMIT 1) AS first_emp_id
		    FROM task_member tm
		    GROUP BY tm.task_id
		) m ON tt.taskId = m.task_id
		LEFT JOIN employee e ON e.emp_id = m.first_emp_id
		LEFT JOIN employee w ON w.emp_id = tt.writerId
		ORDER BY tt.sort_path;

	</select>
	
	<!-- 작업 아이디로 작업 상세 조회 -->
	<select id="selectTaskByTaskId" parameterType="int" resultType="com.example.comma_groupware.dto.ProjectTask">
		SELECT
			task_id AS taskId,
			project_id AS projectId,
			task_status AS taskStatus,
			task_title AS taskTitle,
			task_desc AS taskDesc,
			file_count AS fileCount,
			start_date AS startDate,
			due_date AS dueDate
		FROM
		project_task WHERE task_id = #{id}
	</select>
	
	<!-- 작업 수정 -->
	<update id="modifyProjectTask" parameterType="com.example.comma_groupware.dto.ProjectTask">
		UPDATE project_task 
		<set>
			<if test="taskStatus != ''">task_status = #{taskStatus},</if>
			<if test="taskTitle != ''">task_title = #{taskTitle},</if>
			<if test="taskDesc != ''">task_desc = #{taskDesc},</if>
			<if test="fileCount != null">file_count = #{fileCount},</if>			
			<if test="startDate != null">start_date = #{startDate},</if>
			<if test="dueDate != null">due_date = #{dueDate}</if>
		</set>
		WHERE task_id = #{taskId}
	</update>
	
	<!-- 파일 삭제 -->
	<delete id="deleteTaskFileByFileId" parameterType="int">
		DELETE FROM file_resource WHERE file_id = #{fileId};
	</delete>
	
	<!-- 자식 작업들 조회 -->
	<select id="selectChildTaskIdByTaskId" parameterType="int" resultType="map">
		SELECT 
			task_id AS taskId, 
			task_parent AS taskParent
		FROM project_task WHERE task_parent = #{taskId};
	</select>
	
	<!-- 작업 삭제 -->
	<delete id="deleteTaskByTaskId" parameterType="int">
		DELETE FROM project_task WHERE task_id = #{taskId};
	</delete>
	
	
</mapper>